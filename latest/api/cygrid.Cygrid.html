
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cygrid &#8212; cygrid v2.0.2dev124</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <link rel="shortcut icon" href="../_static/astropy_logo.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Healpix" href="cygrid.Healpix.html" />
    <link rel="prev" title="test" href="cygrid.test.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../index.html"><span id="logotext1">cygrid</span><span id="logotext2"></span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li class="right">
	<a href="cygrid.Healpix.html" title="Healpix">
	  next &raquo;
	</a>
      </li>
      <li class="right">
	<a href="cygrid.test.html" title="test">
	  &laquo; previous
	</a>
	 |
      </li>
      <li>
	<a href="../index.html">cygrid v2.0.2dev124</a>
	 &#187;
      </li>
      <li><a href="../user_manual.html" accesskey="U">Cygrid user manual</a> &#187;</li>
      
      <li>Cygrid</li> 
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="cygrid">
<h1>Cygrid<a class="headerlink" href="#cygrid" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt id="cygrid.Cygrid">
<em class="property">class </em><code class="sig-prename descclassname">cygrid.</code><code class="sig-name descname">Cygrid</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cygrid.Cygrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Fast Cython-powered gridding software, base class.</p>
<p>DO NOT USE DIRECTLY, BUT THE DERIVED CLASSES <a class="reference internal" href="cygrid.WcsGrid.html#cygrid.WcsGrid" title="cygrid.WcsGrid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WcsGrid</span></code></a> OR
<a class="reference internal" href="cygrid.SlGrid.html#cygrid.SlGrid" title="cygrid.SlGrid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SlGrid</span></code></a>.</p>
<p>The underlying algorithm is a based on serialized convolution with finite
gridding kernels. Currently, only Gaussian kernels are provided (which has
the drawback of slight degradation of the effective resolution). The
algorithm has very small memory footprint, allows easy parallelization,
and is very fast.</p>
<p>Look into the <a class="reference internal" href="#cygrid.Cygrid.set_kernel" title="cygrid.Cygrid.set_kernel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_kernel</span></code></a> and <a class="reference internal" href="#cygrid.Cygrid.grid" title="cygrid.Cygrid.grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid</span></code></a>
methods help for more information on how to use this.</p>
<p>Internally, we make use of the HEALPix representation for book-keeping.
The idea is the following: for each input point we query which HEALPix
pixels are located within the required convolution kernel radius (using
HEALPix <code class="xref py py-obj docutils literal notranslate"><span class="pre">query_disc</span></code> function). Likewise, for the target map pixels (any
WCS projection) we calculate the HEALPix index they live in. By a simple
cross- matching (hash-map based) we can thus easily find out which input
pixels contribute to which output pixels. In practice it is a little more
complicated, because world pixels could share the same HEALPix index. We
use lists (or rather C++ vectors) to account for this.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Optional keyword arguments:</strong></dt><dd><dl class="simple">
<dt>dbg_messages<span class="classifier">Boolean (default: False)</span></dt><dd><p>Do debugging output</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods Summary</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cygrid.Cygrid.clear_cache" title="cygrid.Cygrid.clear_cache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear_cache</span></code></a>(self)</p></td>
<td><p>Clear all internal caches/dictionaries.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cygrid.Cygrid.clear_data_and_weights" title="cygrid.Cygrid.clear_data_and_weights"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear_data_and_weights</span></code></a>(self)</p></td>
<td><p>Reset data and weights arrays.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cygrid.Cygrid.get_datacube" title="cygrid.Cygrid.get_datacube"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_datacube</span></code></a>(self)</p></td>
<td><p>Return final data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cygrid.Cygrid.get_unweighted_datacube" title="cygrid.Cygrid.get_unweighted_datacube"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_unweighted_datacube</span></code></a>(self)</p></td>
<td><p>Return final unweighted data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cygrid.Cygrid.get_weights" title="cygrid.Cygrid.get_weights"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_weights</span></code></a>(self)</p></td>
<td><p>Return final weights.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cygrid.Cygrid.grid" title="cygrid.Cygrid.grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid</span></code></a>(self, ndarray lons, ndarray lats, …)</p></td>
<td><p>Grid irregularly positioned data points (spectra) into the data cube.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cygrid.Cygrid.set_kernel" title="cygrid.Cygrid.set_kernel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_kernel</span></code></a>(self, kernel_type, kernel_params, …)</p></td>
<td><p>Set the gridding kernel type and parameters.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cygrid.Cygrid.set_num_threads" title="cygrid.Cygrid.set_num_threads"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_num_threads</span></code></a>(self, int nthreads)</p></td>
<td><p>Change maximum number of threads to use.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods Documentation</p>
<dl class="py method">
<dt id="cygrid.Cygrid.clear_cache">
<code class="sig-name descname">clear_cache</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cygrid.Cygrid.clear_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear all internal caches/dictionaries.</p>
<p class="rubric">Notes</p>
<p>To speed-up processing, <code class="xref py py-obj docutils literal notranslate"><span class="pre">cygrid</span></code> uses internal caches (see <a class="reference external" href="http://adsabs.harvard.edu/abs/2016A%26A...591A..12W">Cygrid
paper</a> for
details). This is usually a minor contribution to the total memory
usage, but there could be scenarios, e.g., when one grids into very
large maps having very small pixel sizes, that the internal cache
grows too much. In this case, we recommend to sort the input data by
latitude, grid the data in chunks, and call this function every now
and then.</p>
</dd></dl>

<dl class="py method">
<dt id="cygrid.Cygrid.clear_data_and_weights">
<code class="sig-name descname">clear_data_and_weights</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cygrid.Cygrid.clear_data_and_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset data and weights arrays. (Caches stay filled!)</p>
</dd></dl>

<dl class="py method">
<dt id="cygrid.Cygrid.get_datacube">
<code class="sig-name descname">get_datacube</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cygrid.Cygrid.get_datacube" title="Permalink to this definition">¶</a></dt>
<dd><p>Return final data.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.array.html#numpy.array" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">array</span></code></a> [nD] of float32 or float64</span></dt><dd><p>The gridded spectral data.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The actual shape of the returned array depends on the input raw
data signal shape and the target pixel array size.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="cygrid.Cygrid.get_unweighted_datacube">
<code class="sig-name descname">get_unweighted_datacube</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cygrid.Cygrid.get_unweighted_datacube" title="Permalink to this definition">¶</a></dt>
<dd><p>Return final unweighted data. (For debugging only.)</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>unweighted_data</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.array.html#numpy.array" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">array</span></code></a> [nD] of float32 or float64</span></dt><dd><p>The gridded spectral unweighted data. The gridded data is
the quotient of the unweighted data and the weights.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The actual shape of the returned array depends on the input raw
data signal shape and the target pixel array size.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="cygrid.Cygrid.get_weights">
<code class="sig-name descname">get_weights</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cygrid.Cygrid.get_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Return final weights.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>weights</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.array.html#numpy.array" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">array</span></code></a> [nD] of float32 or float64</span></dt><dd><p>The gridded spectral weights.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The actual shape of the returned array depends on the input raw
data signal shape and the target pixel array size.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="cygrid.Cygrid.grid">
<code class="sig-name descname">grid</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">ndarray lons</em>, <em class="sig-param">ndarray lats</em>, <em class="sig-param">ndarray data</em>, <em class="sig-param">ndarray weights=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cygrid.Cygrid.grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Grid irregularly positioned data points (spectra) into the data cube.</p>
<p>After successful gridding, you can obtain the resulting datacube with
the <a class="reference internal" href="#cygrid.Cygrid.get_datacube" title="cygrid.Cygrid.get_datacube"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_datacube</span></code></a> method. The associated weight cube
is accessible with <a class="reference internal" href="#cygrid.Cygrid.get_weights" title="cygrid.Cygrid.get_weights"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_weights</span></code></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>lons, lats</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.array.html#numpy.array" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">array</span></code></a> [1D] of float64</span></dt><dd><p>Flat lists/arrays of input coordinates <span class="math notranslate nohighlight">\((l, b)\)</span>.</p>
</dd>
<dt><strong>data/weights</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.array.html#numpy.array" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">array</span></code></a> [nD] of float32 or float64</span></dt><dd><p>The spectra and their weights (optional) for each of the given
coordinate pairs, <span class="math notranslate nohighlight">\((l, b)\)</span>. First axis must match lons/lats
size. The shape of the input data will determine the output
datacube shape: the first axes of the datacube will match the (
raw) data (aka input signal) shape - only the first dimension is
being stripped as it is associated with the number of coordinate
pairs -, while the last axes match the shape of the target pixel
array (e.g., the shape of the target map).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>ShapeError</dt><dd><p>Input coordinates/data points length mismatch.
Number of spectral channels mismatch.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Internally, <code class="xref py py-obj docutils literal notranslate"><span class="pre">cygrid</span></code> always works with a 3D representation of the
data cube, i.e., with (possibly redundant) spectral axis. However,
as the original shape is stored, the gridded data returned by
<a class="reference internal" href="#cygrid.Cygrid.get_datacube" title="cygrid.Cygrid.get_datacube"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_datacube</span></code></a> will always be consistent with the
input raw data signal (in terms of dimensions).</p></li>
<li><p>All input parameters need to be C-contiguous (<code class="xref py py-obj docutils literal notranslate"><span class="pre">cygrid</span></code> will
re-cast if necessary).</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="cygrid.Cygrid.set_kernel">
<code class="sig-name descname">set_kernel</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">kernel_type</em>, <em class="sig-param">kernel_params</em>, <em class="sig-param">double sphere_radius</em>, <em class="sig-param">double hpx_max_resolution</em><span class="sig-paren">)</span><a class="headerlink" href="#cygrid.Cygrid.set_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the gridding kernel type and parameters.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>kernel_type</strong><span class="classifier">str</span></dt><dd><p>Set the kernel type.</p>
<p>The following names/types are available:
‘gauss1d’, ‘gauss2d’, ‘tapered_sinc’ (see Notes for details)</p>
</dd>
<dt><strong>kernel_params</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.array.html#numpy.array" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">array</span></code></a></span></dt><dd><p>Set the kernel parameters for the chosen type (see Notes for
details)</p>
</dd>
<dt><strong>sphere_radius</strong><span class="classifier">double</span></dt><dd><p>Kernel sphere radius.</p>
<p>This is controls out to which distance the kernel
is computed for. For Gaussian kernels, values much larger
than <span class="math notranslate nohighlight">\(3\ldots4 \sigma_\mathrm{k}\)</span> do not make much sense.</p>
</dd>
<dt><strong>hpx_max_resolution</strong><span class="classifier">double</span></dt><dd><p>Maximum acceptable HPX resolution
(<span class="math notranslate nohighlight">\(\sigma_\mathrm{k}^{[\mathrm{maj}]} / 2\)</span> is a
reasonable value).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Below you find a list of kernel-names and required parameters:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;gauss1d&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">kernel_sigma</span><span class="p">,)</span>
<span class="s1">&#39;gauss2d&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">kernel_sigma_maj</span><span class="p">,</span> <span class="n">kernel_sigma_min</span><span class="p">,</span> <span class="n">PA</span><span class="p">)</span>
<span class="s1">&#39;tapered_sinc&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">kernel_sigma</span><span class="p">,</span> <span class="n">param_a</span><span class="p">,</span> <span class="n">param_b</span><span class="p">)</span>
</pre></div>
</div>
<p>All numbers are in units of degrees, except for <code class="xref py py-obj docutils literal notranslate"><span class="pre">PA</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">param_a</span></code> and
<code class="xref py py-obj docutils literal notranslate"><span class="pre">param_b</span></code>. <code class="xref py py-obj docutils literal notranslate"><span class="pre">PA</span></code> (the position angle) is in units of radians (for
efficiency). <code class="xref py py-obj docutils literal notranslate"><span class="pre">param_a</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">param_b</span></code> should be <code class="xref py py-obj docutils literal notranslate"><span class="pre">2.52</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">1.55</span></code>,
respectively, for optimal results!</p>
<p>The kernel size (sigma) defines the amount of “smoothness”
applied to the data. If in doubt a good value is about 50%
of the true/input angular resolution of the data (this will result
in about 10% degradation of the final angular resolution.)</p>
</dd></dl>

<dl class="py method">
<dt id="cygrid.Cygrid.set_num_threads">
<code class="sig-name descname">set_num_threads</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">int nthreads</em><span class="sig-paren">)</span><a class="headerlink" href="#cygrid.Cygrid.set_num_threads" title="Permalink to this definition">¶</a></dt>
<dd><p>Change maximum number of threads to use.</p>
<p>This is a convenience function, to call <code class="xref py py-obj docutils literal notranslate"><span class="pre">omp_set_num_threads()</span></code>,
which is otherwise not possible during runtime from Python.</p>
</dd></dl>

</dd></dl>

</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>
<ul>
<li><a class="reference internal" href="#">Cygrid</a></li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right">
    <a href="https://github.com/bwinkel/cygrid/tree/master/docs/api/cygrid.Cygrid.rst">Edit This Page on Github</a> &nbsp;
    <a href="../_sources/api/cygrid.Cygrid.rst.txt"
       rel="nofollow">Page Source</a> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2021, Benjamin Winkel, Lars Flöer, Daniel Lenz.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 3.4.3. &nbsp;
    Last built 25 Jan 2021. <br/>
  </p>
</footer>
  </body>
</html>